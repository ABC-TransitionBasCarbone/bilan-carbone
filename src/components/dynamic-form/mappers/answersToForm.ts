import { FormValues } from '../types/formTypes'
import { Answer, Question } from '../types/questionTypes'
import { TypeConverter } from './typeConverters'

export const answersToFormValues = (questions: Question[], answers?: Answer[]): FormValues => {
  const formValues: FormValues = {}

  questions.forEach((question) => {
    const answer = answers?.find((a) => a.questionId === question.id)

    const context = {
      questionType: question.type,
      format: question.format,
      possibleAnswers: question.possibleAnswers,
    }

    if (answer && answer.responses.length > 0) {
      formValues[question.idIntern] = TypeConverter.responsesToFormValue(answer.responses, context)
    } else {
      formValues[question.idIntern] = TypeConverter.getDefaultValue(context)
    }
  })

  return formValues
}

export const getAnswerForQuestion = (question: Question, answers: Answer[]): Answer | undefined => {
  return answers.find((a) => a.questionId === question.id)
}

export const getFormValueForQuestion = (question: Question, formValues: FormValues): unknown => {
  return formValues[question.idIntern]
}

export const updateAnswerWithFormValue = (existingAnswer: Answer, newValue: unknown, question: Question): Answer => {
  const context = {
    questionType: question.type,
    format: question.format,
    possibleAnswers: question.possibleAnswers,
  }

  const responses = TypeConverter.formValueToResponses(newValue, context)

  return {
    ...existingAnswer,
    responses,
    updatedAt: new Date(),
  }
}

export const createAnswerFromFormValue = (value: unknown, question: Question, studyId: string): Answer => {
  const context = {
    questionType: question.type,
    format: question.format,
    possibleAnswers: question.possibleAnswers,
  }

  const responses = TypeConverter.formValueToResponses(value, context)

  return {
    id: '', // Will be generated by server
    questionId: question.id,
    studyId,
    responses,
    createdAt: new Date(),
    updatedAt: new Date(),
  }
}
