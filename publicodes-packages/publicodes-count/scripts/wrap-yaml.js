#!/usr/bin/env node

/**
 * YAML Block Wrapper for Publicodes Files
 *
 * Automatically wraps long lines in YAML folded blocks (>) to 80 characters
 * in .publicodes files. This script transforms long lines in description: >
 * and note: > blocks into multiple lines respecting the 80-character limit.
 *
 * @author Generated by Claude Sonnet 4.5 (Anthropic) via opencode
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

// ESM equivalent of __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Constants
const DEFAULT_WIDTH = 80;
const DEFAULT_INDENT = 4;
const FOLDED_BLOCK_PATTERN = /^(\s*)(description|note): >$/;
const PUBLICODES_EXTENSION = ".publicodes";

/**
 * Wraps text to a specified width while preserving word boundaries
 *
 * @param {string} text - The text to wrap
 * @param {number} maxWidth - Maximum line width (default: 80)
 * @param {number} blockIndent - Indentation level of the block
 * @returns {string} Wrapped text with proper indentation
 */
function wrapText(
  text,
  maxWidth = DEFAULT_WIDTH,
  blockIndent = DEFAULT_INDENT,
) {
  const words = text.split(/\s+/).filter(Boolean); // Remove empty strings
  const lines = [];
  const indentStr = " ".repeat(blockIndent);
  const effectiveWidth = maxWidth - blockIndent;

  let currentLine = "";

  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;

    if (testLine.length <= effectiveWidth) {
      currentLine = testLine;
    } else {
      if (currentLine) {
        lines.push(currentLine);
      }
      currentLine = word;
    }
  }

  // Push the last line if it exists
  if (currentLine) {
    lines.push(currentLine);
  }

  // Apply indentation to all lines except the first
  return lines
    .map((line, index) => (index === 0 ? line : indentStr + line))
    .join("\n");
}

/**
 * Processes a single .publicodes file and wraps folded YAML blocks
 *
 * @param {string} filePath - Path to the file to process
 * @returns {boolean} True if the file was modified
 */
function processFile(filePath) {
  const content = fs.readFileSync(filePath, "utf8");
  const lines = content.split("\n");
  const result = [];

  let lineIndex = 0;
  let wasModified = false;

  while (lineIndex < lines.length) {
    const line = lines[lineIndex];
    const match = line.match(FOLDED_BLOCK_PATTERN);

    if (match) {
      const baseIndent = match[1].length;
      const blockIndent = baseIndent + 2; // Standard YAML indentation
      const indentStr = " ".repeat(blockIndent);

      result.push(line);
      lineIndex++;

      // Collect all lines belonging to this block
      const blockLines = [];
      while (
        lineIndex < lines.length &&
        (lines[lineIndex].startsWith(indentStr) ||
          lines[lineIndex].trim() === "")
      ) {
        const trimmedLine = lines[lineIndex].trim();
        if (trimmedLine) {
          blockLines.push(trimmedLine);
        }
        lineIndex++;
      }

      // Process the block if it contains text
      if (blockLines.length > 0) {
        const blockText = blockLines.join(" ");
        const wrappedText = wrapText(
          blockText,
          DEFAULT_WIDTH - blockIndent,
          blockIndent,
        );
        const wrappedWithIndent = indentStr + wrappedText;

        // Check if content changed
        const originalBlock = blockLines
          .map((line) => indentStr + line)
          .join("\n");

        if (originalBlock !== wrappedWithIndent) {
          wasModified = true;
        }

        result.push(wrappedWithIndent);
      }
    } else {
      result.push(line);
      lineIndex++;
    }
  }

  // Write back only if modified
  if (wasModified) {
    fs.writeFileSync(filePath, result.join("\n"), "utf8");
    console.log(`✓ Wrapped: ${path.relative(process.cwd(), filePath)}`);
    return true;
  }

  return false;
}

/**
 * Recursively finds all .publicodes files in a directory
 *
 * @param {string} dir - Directory to scan
 * @returns {string[]} Array of file paths
 */
function findPublicodesFiles(dir) {
  if (!fs.existsSync(dir)) {
    return [];
  }

  const files = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      files.push(...findPublicodesFiles(fullPath));
    } else if (entry.name.endsWith(PUBLICODES_EXTENSION)) {
      files.push(fullPath);
    }
  }

  return files;
}

/**
 * Main execution function
 */
function main() {
  const args = process.argv.slice(2);
  let filesToProcess = [];

  // Process specific files if provided as arguments
  if (args.length > 0) {
    filesToProcess = args.filter((file) => file.endsWith(PUBLICODES_EXTENSION));
  } else {
    // Otherwise, scan the entire src/ directory
    const srcDir = path.join(__dirname, "..", "src");
    filesToProcess = findPublicodesFiles(srcDir);
  }

  if (filesToProcess.length === 0) {
    console.log("No .publicodes files found.");
    return;
  }

  // Process all files
  let modifiedCount = 0;
  for (const file of filesToProcess) {
    if (processFile(file)) {
      modifiedCount++;
    }
  }

  // Display summary
  if (modifiedCount > 0) {
    console.log(`\n✓ Wrapped ${modifiedCount} file(s)`);
  } else {
    console.log("✓ All files already properly wrapped");
  }
}

// Execute main function
main();
